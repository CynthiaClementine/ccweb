<!DOCTYPE html>
<html>
	<!--
		Copyright Cynthia Clementine
		July-23-2023
	-->
	<head>
		<title>GTTEATINE</title>
		<meta charset="utf-8">
		<!-- <link rel='icon' href='img/icon.png' type='image/png'/> -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Ubuntu&display=swap" rel="stylesheet">
		<style>
			body {
				background-color: slateblue;
			}

			#convos {
				margin: auto;
				border: black 3px solid;
			}

			#centerModule {
				position: relative;
				text-align: center;
			}
		</style>
		<script src="../common/functions-math.js"></script>
		<script type="text/javascript">
			window.onload = setup;
			window.onkeydown = handleKeyPress;
			window.onkeyup = handleKeyRelease;

			var canvas;
			var ctx;

			var tileWidth = 0.7;
			var sliceTiles = 5;
			var sliceOptions = [5, 13];

			var color_bg = "#9ec3ff";
			var color_bridge = "#888888";
			var color_bridgeDark = "#222244";
			var color_water = "#4d4f96";

			var coyoteFrames = 2;

			var bridge = [];
			var bridgeDistMax = 0;
			var bridgeDistChal = 600;
			var bridgeFreqMin = 0.05;
			var player = {
				x: 0,
				y: 0,
				z: 0,

				dx: 0,
				dy: 0,

				strafe: 6.5,
				friction: 0.85,
				jump: 0.2,
				ax: 30,
				ay: 0.7,
				dir: 0,
				speedMin: 3,
				speedMax: 15,
			};
			var playerTrueZ = 0.8;

			var camera = {
				x: 0,
				y: 2.5,
				z: -3,
				scale: 0.65,
			}

			var create;


			var drawDistMax = 20;

			var goFast = false;

			var lastTime = 0;

			function generateBridgeSlice() {
				var sliceIndex = bridge.length;
				var sliceFreq = calcTileFreq(sliceIndex * tileWidth);

				var slice = [];
				for (var t=sliceTiles-1; t>-1; t--) {
					slice[t] = (Math.random() < sliceFreq);
				}
				bridge.push(slice);
			}

			function calcTileFreq(distance) {
				// return sigmoid((distance ** 1.5 / bridgeDistChal) - 6, 1, bridgeFreqMin);
				return Math.E ** -(4 * distance / bridgeDistChal) * (1 - bridgeFreqMin) + bridgeFreqMin;
			}

			function calcZSpeed(distance) {
				return clamp((distance / bridgeDistChal) * player.speedMax, player.speedMin, player.speedMax);
			}

			function spaceToScreen(x, y, z) {
				x -= camera.x;
				y -= camera.y;
				z -= camera.z;

				x /= z;
				y /= z;

				x *= camera.scale * canvas.width;
				y *= -camera.scale * canvas.height;

				x += canvas.width / 2;
				y += canvas.height / 2;

				return [x, y];
			}

			function calcHeight(distance) {
				// return 0;

				return -2 * (distance * (distance - 2 * drawDistMax)) / (drawDistMax ** 2);
			}

			function bridgeToScreen(bridgeX, bridgeZ) {
				return spaceToScreen(tileWidth * (bridge[0].length * -0.5 + bridgeX), calcHeight(bridgeZ - player.z), bridgeZ - player.z);
			}

			function setup() {
				canvas = document.getElementById("corvid");
				ctx = canvas.getContext("2d");

				ctx.lineJoin = "round";

				for (var l=0; l<5; l++) {
					generateBridgeSlice();
				}

				animation = window.requestAnimationFrame(main);
			}

			function main() {
				tick();
				draw();

				animation = window.requestAnimationFrame(main);
			}

			function tick(deltaT, recursiveTimer) {
				var newTime = performance.now();
				if (deltaT == undefined) {
					recursiveTimer = 3;
					deltaT = clamp(newTime - lastTime, 1, 30) / 1000;
					lastTime = newTime;
				}

				//player velocity
				player.dx = clamp(player.dx + player.dir * player.ax * deltaT, -player.strafe, player.strafe);
				if (player.dir * player.dx <= 0) {
					player.dx *= player.friction;
				}

				player.dy -= player.ay * deltaT * 0.5;

				//player coordinates
				var bridgeWidth = tileWidth * (sliceTiles - 0.25) * 0.5;
				player.x = clamp(player.x + player.dx * deltaT, -bridgeWidth, bridgeWidth);
				player.y += player.dy;
				//player dy is split into two bits so its more precisely integrated
				player.dy -= player.ay * deltaT * 0.5;
				if (player.dy < 0 && player.y < 0) {
					player.dy = 0;
					player.y = 0;
				}
				player.z += calcZSpeed(player.z) * deltaT;

				//generate more bridge
				if (player.z + 20 > bridge.length) {
					generateBridgeSlice();
				}

				if (goFast && recursiveTimer > 0) {
					tick(deltaT, recursiveTimer - 1);
				}
			}

			function onGround() {
				var graceFrames = 2;
				var zWid = calcZSpeed(player.z) * coyoteFrames;
				var tileBack = bridge[Math.floor(player.z + playerTrueZ - graceFrames * calcZSpeed(player.z))]
				return ((tileAt(player.x, player.z)) != false);
			}

			function tileAt(x, z) {
				return bridge[Math.floor(z)][Math.floor(x + (sliceTiles * 0.5 * tileWidth))];
			}

			function draw() {
				//background
				ctx.fillStyle = color_bg;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = color_water;
				ctx.fillRect(0, bridgeToScreen(0, player.z + drawDistMax)[1], canvas.width, canvas.height / 2);

				var centerOff = tileWidth / 2;

				//low player shadow
				// coords = spaceToScreen(player.x, 0, playerTrueZ);
				// ctx.globalAlpha = 0.4;
				// drawEllipse(coords[0], coords[1], canvas.height / 12, canvas.height / 24, "#666");
				// ctx.globalAlpha = 1;

				//bridge
				ctx.strokeStyle = color_bridge;
				ctx.lineWidth = canvas.height / 200;
				ctx.fillStyle = color_bridge;
				for (var f=Math.floor(player.z); f<bridge.length; f++) {
					for (var t=0; t<bridge[f].length; t++) {
						if (bridge[f][t]) {
							ctx.beginPath();
							ctx.moveTo(...bridgeToScreen(t, f));
							ctx.lineTo(...bridgeToScreen(t+1, f));
							ctx.lineTo(...bridgeToScreen(t+1, f+1));
							ctx.lineTo(...bridgeToScreen(t, f+1));
							ctx.lineTo(...bridgeToScreen(t, f));
							ctx.fill();
							ctx.stroke();
						}
					}
				}


				//player shadow
				var coords = spaceToScreen(player.x, calcHeight(playerTrueZ), playerTrueZ);
				ctx.globalAlpha = 0.4;
				drawEllipse(coords[0], coords[1], canvas.height / 12, canvas.height / 24, "#666");
				ctx.globalAlpha = 1;

				drawScaffolding();

				//player
				coords = spaceToScreen(player.x, player.y + calcHeight(playerTrueZ), playerTrueZ);
				drawEllipse(coords[0], coords[1] - (canvas.height / 10), canvas.height / 15, canvas.height / 10, "#F8F");
				ctx.stroke();
			}

			function drawScaffolding() {
				var scaffoldingBits = drawDistMax * 2;
				var offX = tileWidth * bridge[0].length * 0.5;
				var offY = 0.1;
				var bitflip = 1;

				var coords = spaceToScreen(offX, calcHeight(0) + offY, 0);
				ctx.beginPath();
				ctx.strokeStyle = color_bridgeDark;
				ctx.moveTo(coords[0], coords[1]);
				ctx.lineWidth = canvas.height / 100;
				while (bitflip > -1) {
					for (var h=0; h<scaffoldingBits; h++) {
						coords = spaceToScreen(offX, calcHeight((h / scaffoldingBits) * drawDistMax) + offY, (h / scaffoldingBits) * drawDistMax);
						ctx.lineTo(coords[0], coords[1]);
					}
					bitflip -= 1;
					offX *= -1;

					coords = spaceToScreen(offX, calcHeight(0) + offY, 0);
					ctx.moveTo(coords[0], coords[1]);
				}
				ctx.stroke();
			}

			function drawEllipse(x, y, rx, ry, color) {
				ctx.fillStyle = color;
				ctx.beginPath();
				ctx.ellipse(x, y, rx, ry, 0, 0, Math.PI * 2);
				ctx.fill();
			}

			function handleKeyPress(a) {
				switch(a.code) {
					case "ArrowLeft":
						player.dir = -1;
						break;
					case "ArrowUp":
						player.dy = player.jump;
						break;
					case "ArrowRight":
						player.dir = 1;
						break;

					case "ShiftLeft":
					case "ShiftRight":
						goFast = true;
						break;
				}
			}

			function handleKeyRelease(a) {
				switch(a.code) {
					case "ArrowLeft":
						if (player.dir < 0) {
							player.dir = 0;
						}
						break;
					case "ArrowRight":
						if (player.dir > 0) {
							player.dir = 0;
						}
						break;

					case "ShiftLeft":
					case "ShiftRight":
						goFast = false;
						break;
				}
			}

		</script>
	</head>
	<body>
		<div id="centerModule">
			<canvas id="corvid" width="640" height="480"></canvas><br>
			<p id="statusText">Welcome to Get To The End Although There Is No End!<br>what? to the top? never heard of it. </p>
		</div>
	</body>
</html>