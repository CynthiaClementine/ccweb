<html>
	<head>
		<title>Satellite!</title>
		<style>
			body {
				background-color: slateblue;
			}

			#cavalier {
				margin: auto;
				text-align: center;
				display: block;
			}

			#centerModule {
				text-align: center;
				margin: auto;
			}
		</style>
		<script src="common/functions-coordinate.js"></script>
		<script src="common/functions-math.js"></script>
		<script>
			window.onload = setup;
			window.onkeydown = handleKeyDown;
			window.onkeyup = handleKeyUp;
			var canvas;
			var ctx;
			var centerX;
			var centerY;


			var cameraDist = 45000000;
			var camera = {
				x: 0,
				y: 0,
				z: -cameraDist,
				theta: 0,
				phi: 0,
				rot: 0,
				scale: 1200,

				dt: 0,
				dp: 0,
			};

			var colorEarth = "#45f6ff";
			var colorGround = "#ffd500";
			var colorSat = "#fbd1ff";
			var colorLink = "#0afa16";

			//seconds per frame
			var dt = 30;
			//mass, radius, and G are all in base units (kg, m, and m^3/kg s^2 respectively)
			var earthMass = 5.972E24;
			var earthRadius = 6371000;
			//23 hours, 56 minutes, and 4.09 seconds
			//earth's rotational period, in seconds
			var earthPeriod = 23 * 60*60 + 56 * 60 + 4.09;
			var earthMarkPos = [0, 0, 0];
			var earthRingNum = 21;
			
			var gravityConstant = 6.6743E-11;

			//orbit presets are in the format [satellite position, satellite velocity, ground position]
			var orbitPresets = {
				"ISS-WASH": [
					polToCart(0, 0, earthRadius + 408000),
					polToCart(Math.PI / 2, radians(51.65), 7660),
					// polToCart(Math.PI / 2, 0, 7660),
					polToCart(radians(77.0369), radians(38.9072), earthRadius)
				]
			}
		
			var satPos = [0, 0, 0];
			var satVel = [0, 0, 0];
			var satFOV = radians(45);

			var timer;

			//setup function
			function setup() {
				canvas = document.getElementById("caviar");
				ctx = canvas.getContext("2d");

				
				centerX = canvas.width * 0.5;
				centerY = canvas.height * 0.5;
				
				loadPreset("ISS-WASH");
				timer = window.requestAnimationFrame(main);
			}

			function main() {
				tick();
				draw();
				timer = window.requestAnimationFrame(main);
			}

			//the earth is located at 0,0,0, so gravity strength is just proportional to distance
			function gravitate(x, y, z) {
				var dist = Math.sqrt(x*x + y*y + z*z);
				var g = (gravityConstant * earthMass) / (dist*dist);
				//g pulls towards the center, so it now must be converted into a vector

				console.log(dist, g);

				return [-x / dist * g, -y / dist * g, -z / dist * g];
			}

			function tick() {
				//move satellite
				satPos[0] += satVel[0] * dt;
				satPos[1] += satVel[1] * dt;
				satPos[2] += satVel[2] * dt;


				var gravVec = gravitate(...satPos);
				satVel[0] += gravVec[0] * dt;
				satVel[1] += gravVec[1] * dt;
				satVel[2] += gravVec[2] * dt;

				//rotate the earth
				[earthMarkPos[0], earthMarkPos[2]] = rotate(earthMarkPos[0], earthMarkPos[2], (2 * Math.PI / earthPeriod) * dt);

				//move the connection line

				//rotate the camera
				camera.theta += camera.dt * 0.01;
				camera.phi = clamp(camera.phi + camera.dp * 0.01, -Math.PI * 0.5, Math.PI * 0.5);

				[camera.x, camera.y, camera.z] = polToCart(-camera.theta, -camera.phi, -cameraDist);
			}

			function draw() {
				//to make the drawing layer correctly, some objects need to be binned behind the earth and some need to be binned in front of the earth. 
				//Which objects these are exactly depends on their z-position
				//so my solution is to calculate everything's z position, bin that, and then draw the bins

				//each object will either get an [x, y, color] or [x1, y1, x2, y2, color] array
				var backBin = [];
				var frontBin = [];

				//ground waypoint position
				// var spaceToRelative()

				//satellite ring
				
				//satellite position



				//background
				ctx.fillStyle = "#000";
				ctx.fillRect(0, 0, canvas.width, canvas.height);


				//draw all pre-earth objects
				
				//draw the earth, with all its rings
				ctx.fillStyle = colorEarth;
				ctx.strokeStyle = colorEarth;
				var phiPerRing = Math.PI / earthRingNum;
				var sidePos;
				var midPos;
				var backPos;

				for (var r=0; r<earthRingNum; r++) {
					ctx.beginPath();
					var pos;
					for (var s=0; s<=20; s++) {
						pos = polToCart(Math.PI * s * 2 / 20, (Math.PI / -2) + r * phiPerRing, earthRadius);
						pos = spaceToScreen(pos);
						ctx.lineTo(pos[0], pos[1]);
					}


					// ctx.ellipse(midPos[0], midPos[1], Math.abs(sidePos[0] - midPos[0]), Math.abs(backPos[1] - midPos[1]), 0, 0, Math.PI * 2);
					ctx.stroke();
				}

				//draw the earth's highlighted location
				var pos = spaceToScreen(earthMarkPos);
				ctx.fillStyle = colorGround;
				ctx.fillRect(pos[0] - 2, pos[1] - 2, 4, 4);

				//draw the satellite ring

				//draw the satellite
				pos = spaceToScreen(satPos);
				ctx.fillStyle = colorSat;
				ctx.fillRect(pos[0] - 2, pos[1] - 2, 4, 4);
			}

			function loadPreset(preset) {
				var orbDat = orbitPresets[preset];
				//make sure these are values, not references
				orbDat = JSON.parse(JSON.stringify(orbDat));
				satPos = orbDat[0];
				satVel = orbDat[1];
				earthMarkPos = orbDat[2];

				console.log(satPos, gravitate(...satPos));
			}

			function radians(degree) {
				return degree * Math.PI / 180;
			}

			//takes a point in relative camera coords and puts it on the screen
			function relativeToScreen(tCoords) {
				//divide by axis perpendicular to camera
				if (tCoords[2] < 0) {
					return [NaN, NaN];
				}
				tCoords[0] /= tCoords[2];
				tCoords[1] /= tCoords[2];

				tCoords[0] *= camera.scale;
				tCoords[1] *= -1 * camera.scale;

				//account for screen coordinates and return
				return [tCoords[0] + canvas.width / 2, tCoords[1] + canvas.height / 2];
			}

			function spaceToRelative(pointToChange, point, normal) {
				var tCoords = [pointToChange[0] - point[0], pointToChange[1] - point[1], pointToChange[2] - point[2]];

				[tCoords[0], tCoords[2]] = rotate(tCoords[0], tCoords[2], -normal[0]);
				[tCoords[1], tCoords[2]] = rotate(tCoords[1], tCoords[2], -normal[1]);

				return tCoords;
			}

			//converts a world point to screen coordinates
			function spaceToScreen(point) {
				//handy that this whole algorithm is in other functions
				return relativeToScreen(spaceToRelative(point, [camera.x, camera.y, camera.z], [camera.theta, camera.phi]));
			}

			function handleKeyDown(e) {
				switch(e.code) {
					case "ArrowLeft":
						camera.dt = 1;
						break;
					case "ArrowUp":
						camera.dp = -1;
						break;
					case "ArrowRight":
						camera.dt = -1;
						break;
					case "ArrowDown":
						camera.dp = 1;
						break;
				}
			}

			function handleKeyUp(e) {
				switch(e.code) {
					case "ArrowLeft":
						camera.dt = Math.min(camera.dt, 0);
						break;
					case "ArrowUp":
						camera.dp = Math.max(camera.dp, 0);
						break;
					case "ArrowRight":
					camera.dt = Math.max(camera.dt, 0);
						break;
					case "ArrowDown":
					camera.dp = Math.min(camera.dp, 0);
						break;
				}
			}
		</script>
	</head>
	<body>
		<div id="centerModule">
		<canvas id="caviar" width="1280" height="960"></canvas><br>
		<p id="explanText">
			How does this work?<br>
		</p>
		</div>
	</body>
</html>